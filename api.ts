/**
 * Tortoise Merchant API
 * Tortoise API for merchant to integrate with their existing systems 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: developer@tortoise.pro
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://virtserver.swaggerhub.com/suryaharshan1/Tortoise/1.0.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Cancellation {
    /**
    * Unique identifier for the cancellation request
    */
    'id'?: string;
    'plan'?: Plan;
    'requestRaisedOn'?: Date;
    'requestProcessedOn'?: Date;
    'status'?: Cancellation.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "Plan"
        },
        {
            "name": "requestRaisedOn",
            "baseName": "requestRaisedOn",
            "type": "Date"
        },
        {
            "name": "requestProcessedOn",
            "baseName": "requestProcessedOn",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Cancellation.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return Cancellation.attributeTypeMap;
    }
}

export namespace Cancellation {
    export enum StatusEnum {
        Raised = <any> 'raised',
        Processing = <any> 'processing',
        RefundInitiated = <any> 'refundInitiated',
        Successful = <any> 'successful',
        Cancelled = <any> 'cancelled',
        Failed = <any> 'failed'
    }
}
export class Customer {
    /**
    * Unique identifier for the customer
    */
    'id'?: string;
    /**
    * Customer's first name. For example, Surya Harsha
    */
    'firstName'?: string;
    /**
    * Customer's last name. For example, Singh
    */
    'lastName'?: string;
    'email'?: string;
    'mobile'?: string;
    'countryCode'?: string;
    'age'?: number;
    'gender'?: Customer.GenderEnum;
    'kycStatus'?: Customer.KycStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "mobile",
            "baseName": "mobile",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "age",
            "baseName": "age",
            "type": "number"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "Customer.GenderEnum"
        },
        {
            "name": "kycStatus",
            "baseName": "kycStatus",
            "type": "Customer.KycStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

export namespace Customer {
    export enum GenderEnum {
        Male = <any> 'male',
        Female = <any> 'female',
        Other = <any> 'other'
    }
    export enum KycStatusEnum {
        Pending = <any> 'pending',
        InProcess = <any> 'inProcess',
        Verified = <any> 'verified',
        Failed = <any> 'failed'
    }
}
export class Payment {
    /**
    * Unique identifier for the payment
    */
    'id'?: string;
    'plan'?: Plan;
    /**
    * Instalment serial number for which the payment has been made
    */
    'instalmentId'?: number;
    /**
    * Mode of payment
    */
    'mode'?: Payment.ModeEnum;
    /**
    * Amount paid on the payment
    */
    'amount'?: number;
    /**
    * Timestamp at which the payment has been made
    */
    'createdOn'?: Date;
    /**
    * Status of the payment
    */
    'status'?: Payment.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "Plan"
        },
        {
            "name": "instalmentId",
            "baseName": "instalmentId",
            "type": "number"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "Payment.ModeEnum"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Payment.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return Payment.attributeTypeMap;
    }
}

export namespace Payment {
    export enum ModeEnum {
        Debit = <any> 'debit',
        Credit = <any> 'credit',
        Upi = <any> 'upi',
        Netbanking = <any> 'netbanking',
        Cash = <any> 'cash'
    }
    export enum StatusEnum {
        Successful = <any> 'successful',
        Failed = <any> 'failed',
        Refunded = <any> 'refunded',
        RefundInitiated = <any> 'refundInitiated',
        Processing = <any> 'processing'
    }
}
export class Plan {
    /**
    * Unique identifier for the plan
    */
    'id'?: string;
    'customer'?: PlanCustomer;
    'product'?: PlanProduct;
    'scheme'?: PlanScheme;
    /**
    * Time when customer enrolled on the plan
    */
    'enrolledOn'?: Date;
    /**
    * Total price of the plan, to be paid by the customer
    */
    'planValue'?: number;
    /**
    * Value of each instalment to be paid by the customer
    */
    'instalmentValue'?: number;
    /**
    * Total amount paid by the customer towards the plan till date
    */
    'totalPaidValue'?: number;
    /**
    * Instalments paid by customer till date
    */
    'completedInstalments'?: number;
    /**
    * Due date for the upcoming instalment of the plan
    */
    'nextInstalmentDate'?: string;
    /**
    * Date on which the plan is expected to mature
    */
    'planMaturityDate'?: string;
    /**
    * Total amount expected to be redeemed by the customer at the end of the plan
    */
    'totalExpectedRedemptionValue'?: number;
    /**
    * Total amount that can be redeemed by the customer by closing the plan today
    */
    'currentRedemptionValue'?: number;
    /**
    * Total amount that is paid back to customer if the plan is cancelled today
    */
    'currentCancellationValue'?: number;
    /**
    * Timestamp of last paid instalment
    */
    'lastInstalmentPaidOn'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "PlanCustomer"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "PlanProduct"
        },
        {
            "name": "scheme",
            "baseName": "scheme",
            "type": "PlanScheme"
        },
        {
            "name": "enrolledOn",
            "baseName": "enrolledOn",
            "type": "Date"
        },
        {
            "name": "planValue",
            "baseName": "planValue",
            "type": "number"
        },
        {
            "name": "instalmentValue",
            "baseName": "instalmentValue",
            "type": "number"
        },
        {
            "name": "totalPaidValue",
            "baseName": "totalPaidValue",
            "type": "number"
        },
        {
            "name": "completedInstalments",
            "baseName": "completedInstalments",
            "type": "number"
        },
        {
            "name": "nextInstalmentDate",
            "baseName": "nextInstalmentDate",
            "type": "string"
        },
        {
            "name": "planMaturityDate",
            "baseName": "planMaturityDate",
            "type": "string"
        },
        {
            "name": "totalExpectedRedemptionValue",
            "baseName": "totalExpectedRedemptionValue",
            "type": "number"
        },
        {
            "name": "currentRedemptionValue",
            "baseName": "currentRedemptionValue",
            "type": "number"
        },
        {
            "name": "currentCancellationValue",
            "baseName": "currentCancellationValue",
            "type": "number"
        },
        {
            "name": "lastInstalmentPaidOn",
            "baseName": "lastInstalmentPaidOn",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Plan.attributeTypeMap;
    }
}

/**
* Customer who owns the plan
*/
export class PlanCustomer {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PlanCustomer.attributeTypeMap;
    }
}

/**
* Product associated with the plan
*/
export class PlanProduct {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PlanProduct.attributeTypeMap;
    }
}

/**
* Scheme that is used to start a plan
*/
export class PlanScheme {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PlanScheme.attributeTypeMap;
    }
}

export class Product {
    /**
    * Unique Identifier for the product
    */
    'id'?: string;
    /**
    * Name of the product
    */
    'name'?: string;
    /**
    * Name of the category that product belongs to
    */
    'category'?: string;
    'status'?: Product.StatusEnum;
    'price'?: number;
    'createdOn'?: Date;
    'updatedOn'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Product.StatusEnum"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "Date"
        },
        {
            "name": "updatedOn",
            "baseName": "updatedOn",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Product.attributeTypeMap;
    }
}

export namespace Product {
    export enum StatusEnum {
        Active = <any> 'active',
        Disabled = <any> 'disabled',
        ReviewPending = <any> 'reviewPending',
        ReviewRejected = <any> 'reviewRejected'
    }
}
export class Redemption {
    /**
    * Unique identifier for the redemption request
    */
    'id'?: string;
    'plan'?: Plan;
    'requestRaisedOn'?: Date;
    'requestProcessedOn'?: Date;
    'status'?: Redemption.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "Plan"
        },
        {
            "name": "requestRaisedOn",
            "baseName": "requestRaisedOn",
            "type": "Date"
        },
        {
            "name": "requestProcessedOn",
            "baseName": "requestProcessedOn",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Redemption.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return Redemption.attributeTypeMap;
    }
}

export namespace Redemption {
    export enum StatusEnum {
        Raised = <any> 'raised',
        Processing = <any> 'processing',
        Successful = <any> 'successful',
        Failed = <any> 'failed'
    }
}
export class Scheme {
    /**
    * Unique identifier for the scheme
    */
    'id'?: string;
    /**
    * Name of the scheme
    */
    'name'?: string;
    /**
    * Timestamp at which the scheme is created
    */
    'createdOn'?: Date;
    'status'?: Scheme.StatusEnum;
    'redemptionOption'?: SchemeRedemptionOption;
    /**
    * Duration of the scheme in months, in other words, number of instalments to be paid by the customer
    */
    'durationInMonths'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Scheme.StatusEnum"
        },
        {
            "name": "redemptionOption",
            "baseName": "redemptionOption",
            "type": "SchemeRedemptionOption"
        },
        {
            "name": "durationInMonths",
            "baseName": "durationInMonths",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Scheme.attributeTypeMap;
    }
}

export namespace Scheme {
    export enum StatusEnum {
        Active = <any> 'active',
        Disabled = <any> 'disabled',
        ReviewPending = <any> 'reviewPending',
        ReviewRejected = <any> 'reviewRejected'
    }
}
export class SchemeRedemptionOption {
    /**
    * month after which the redemption can be applied
    */
    'startMonth'?: number;
    /**
    * date in the above month after which the redemption can be applied
    */
    'startDate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SchemeRedemptionOption.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Cancellation.StatusEnum": Cancellation.StatusEnum,
        "Customer.GenderEnum": Customer.GenderEnum,
        "Customer.KycStatusEnum": Customer.KycStatusEnum,
        "Payment.ModeEnum": Payment.ModeEnum,
        "Payment.StatusEnum": Payment.StatusEnum,
        "Product.StatusEnum": Product.StatusEnum,
        "Redemption.StatusEnum": Redemption.StatusEnum,
        "Scheme.StatusEnum": Scheme.StatusEnum,
}

let typeMap: {[index: string]: any} = {
    "Cancellation": Cancellation,
    "Customer": Customer,
    "Payment": Payment,
    "Plan": Plan,
    "PlanCustomer": PlanCustomer,
    "PlanProduct": PlanProduct,
    "PlanScheme": PlanScheme,
    "Product": Product,
    "Redemption": Redemption,
    "Scheme": Scheme,
    "SchemeRedemptionOption": SchemeRedemptionOption,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CancellationApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class CancellationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CancellationApiApiKeys, value: string) {
        (this.authentications as any)[CancellationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new cancellation request for a plan
     * @param body cancellation object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addCancellation (body: Cancellation, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/cancellations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addCancellation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Cancellation")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a cancellation request for a plan
     * @param cancellationId ID of the cancellation to edit
     * @param body Cancellation object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editCancellation (cancellationId: string, body: Cancellation, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/cancellations/{cancellationId}'
            .replace('{' + 'cancellationId' + '}', encodeURIComponent(String(cancellationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cancellationId' is not null or undefined
        if (cancellationId === null || cancellationId === undefined) {
            throw new Error('Required parameter cancellationId was null or undefined when calling editCancellation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editCancellation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Cancellation")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all cancellations
     * @param {*} [options] Override http request options.
     */
    public fetchAllCancellations (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Cancellation>;  }> {
        const localVarPath = this.basePath + '/cancellations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Cancellation>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Cancellation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get cancellation by ID
     * @param cancellationId ID of the cancellation to fetch
     * @param {*} [options] Override http request options.
     */
    public getCancellation (cancellationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Cancellation;  }> {
        const localVarPath = this.basePath + '/cancellations/{cancellationId}'
            .replace('{' + 'cancellationId' + '}', encodeURIComponent(String(cancellationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cancellationId' is not null or undefined
        if (cancellationId === null || cancellationId === undefined) {
            throw new Error('Required parameter cancellationId was null or undefined when calling getCancellation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cancellation;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cancellation");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class CustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        (this.authentications as any)[CustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new customer
     * @param body Customer object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addCustomer (body: Customer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Customer;  }> {
        const localVarPath = this.basePath + '/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Customer")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Customer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Customer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit customer details
     * @param customerId ID of customer to edit
     * @param body Customer object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editCustomer (customerId: string, body: Customer, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/customers/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling editCustomer.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Customer")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all customers
     * @param {*} [options] Override http request options.
     */
    public fetchAllCustomers (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Customer>;  }> {
        const localVarPath = this.basePath + '/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Customer>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Customer>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get customer by ID
     * @param customerId ID of customer to get
     * @param {*} [options] Override http request options.
     */
    public getCustomer (customerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Customer;  }> {
        const localVarPath = this.basePath + '/customers/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Customer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Customer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class PaymentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentApiApiKeys, value: string) {
        (this.authentications as any)[PaymentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new payment
     * @param body Payment object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addPayment (body: Payment, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Payment")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all payments
     * @param {*} [options] Override http request options.
     */
    public fetchAllPayments (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Payment>;  }> {
        const localVarPath = this.basePath + '/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Payment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Payment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get payment by ID
     * @param paymentId ID of the payment to fetch
     * @param {*} [options] Override http request options.
     */
    public getPayment (paymentId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Payment;  }> {
        const localVarPath = this.basePath + '/payments/{paymentId}'
            .replace('{' + 'paymentId' + '}', encodeURIComponent(String(paymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentId' is not null or undefined
        if (paymentId === null || paymentId === undefined) {
            throw new Error('Required parameter paymentId was null or undefined when calling getPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Payment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Payment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlanApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class PlanApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlanApiApiKeys, value: string) {
        (this.authentications as any)[PlanApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new plan
     * @param body Plan object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addPlan (body: Plan, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Plan")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a plan's details
     * @param planId ID of the plan to edit
     * @param body Plan object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editPlan (planId: string, body: Plan, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/plans/{planId}'
            .replace('{' + 'planId' + '}', encodeURIComponent(String(planId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'planId' is not null or undefined
        if (planId === null || planId === undefined) {
            throw new Error('Required parameter planId was null or undefined when calling editPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Plan")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all plans
     * @param {*} [options] Override http request options.
     */
    public fetchAllPlans (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Plan>;  }> {
        const localVarPath = this.basePath + '/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Plan>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Plan>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a plan by ID
     * @param planId ID of the plan to fetch
     * @param {*} [options] Override http request options.
     */
    public getPlan (planId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Plan;  }> {
        const localVarPath = this.basePath + '/plans/{planId}'
            .replace('{' + 'planId' + '}', encodeURIComponent(String(planId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'planId' is not null or undefined
        if (planId === null || planId === undefined) {
            throw new Error('Required parameter planId was null or undefined when calling getPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Plan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Plan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class ProductApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductApiApiKeys, value: string) {
        (this.authentications as any)[ProductApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new product
     * @param body Product object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addProduct (body: Product, options: any = {}) : Promise<{ response: http.ClientResponse; body: Product;  }> {
        const localVarPath = this.basePath + '/products';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Product")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Product;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Product");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit product details
     * @param productId ID of the product to edit
     * @param body Product object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editProduct (productId: string, body: Product, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/products/{productId}'
            .replace('{' + 'productId' + '}', encodeURIComponent(String(productId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling editProduct.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Product")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all products
     * @param {*} [options] Override http request options.
     */
    public fetchAllProducts (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Product>;  }> {
        const localVarPath = this.basePath + '/products';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Product>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Product>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get product by ID
     * @param productId ID of the product to fetch
     * @param {*} [options] Override http request options.
     */
    public getProduct (productId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Product;  }> {
        const localVarPath = this.basePath + '/products/{productId}'
            .replace('{' + 'productId' + '}', encodeURIComponent(String(productId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Product;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Product");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RedemptionApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class RedemptionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RedemptionApiApiKeys, value: string) {
        (this.authentications as any)[RedemptionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new redemption request for a plan
     * @param body Redemption object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addRedemption (body: Redemption, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/redemptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Redemption")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a redemption request for a plan
     * @param redemptionId ID of the redemption to edit
     * @param body Redemption object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editRedemption (redemptionId: string, body: Redemption, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/redemptions/{redemptionId}'
            .replace('{' + 'redemptionId' + '}', encodeURIComponent(String(redemptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'redemptionId' is not null or undefined
        if (redemptionId === null || redemptionId === undefined) {
            throw new Error('Required parameter redemptionId was null or undefined when calling editRedemption.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Redemption")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all redemption requests
     * @param {*} [options] Override http request options.
     */
    public fetchAllRedemptions (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Redemption>;  }> {
        const localVarPath = this.basePath + '/redemptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Redemption>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Redemption>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a redemption request by ID
     * @param redemptionId ID of the redemption to fetch
     * @param {*} [options] Override http request options.
     */
    public getRedemption (redemptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Redemption;  }> {
        const localVarPath = this.basePath + '/redemptions/{redemptionId}'
            .replace('{' + 'redemptionId' + '}', encodeURIComponent(String(redemptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'redemptionId' is not null or undefined
        if (redemptionId === null || redemptionId === undefined) {
            throw new Error('Required parameter redemptionId was null or undefined when calling getRedemption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Redemption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Redemption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SchemeApiApiKeys {
    tortoise_merchant_apiKey,
    tortoise_merchant_appId,
}

export class SchemeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tortoise_merchant_apiKey': new ApiKeyAuth('header', 'X-TORTOISE-KEY'),
        'tortoise_merchant_appId': new ApiKeyAuth('header', 'X-TORTOISE-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SchemeApiApiKeys, value: string) {
        (this.authentications as any)[SchemeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a new scheme
     * @param body Scheme object that needs to be added
     * @param {*} [options] Override http request options.
     */
    public addScheme (body: Scheme, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/schemes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addScheme.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Scheme")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit scheme details
     * @param schemeId ID of the scheme to edit
     * @param body Scheme object that needs to be edited
     * @param {*} [options] Override http request options.
     */
    public editScheme (schemeId: string, body: Scheme, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/schemes/{schemeId}'
            .replace('{' + 'schemeId' + '}', encodeURIComponent(String(schemeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'schemeId' is not null or undefined
        if (schemeId === null || schemeId === undefined) {
            throw new Error('Required parameter schemeId was null or undefined when calling editScheme.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editScheme.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Scheme")
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch all schemes
     * @param {*} [options] Override http request options.
     */
    public fetchAllSchemes (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Scheme>;  }> {
        const localVarPath = this.basePath + '/schemes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Scheme>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Scheme>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get scheme by ID
     * @param schemeId ID of the scheme to fetch
     * @param {*} [options] Override http request options.
     */
    public getScheme (schemeId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Scheme;  }> {
        const localVarPath = this.basePath + '/schemes/{schemeId}'
            .replace('{' + 'schemeId' + '}', encodeURIComponent(String(schemeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'schemeId' is not null or undefined
        if (schemeId === null || schemeId === undefined) {
            throw new Error('Required parameter schemeId was null or undefined when calling getScheme.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.tortoise_merchant_apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.tortoise_merchant_appId.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Scheme;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Scheme");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
